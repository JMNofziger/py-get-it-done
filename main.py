from flask import Flask, request, redirect, render_template, session, flash
from flask_sqlalchemy import SQLAlchemy
import configparser 

app = Flask(__name__)
app.config['DEBUG'] = True

# parse config ini file to get needed uri as described below
dbconfig = configparser.ConfigParser()
dbconfig.read("db-info.ini")
uristring = dbconfig.get("dbconfig","mysecret")

# type of database we are connecting to  '+' mysql driver then --> ://
# databaseuser:databasepassword@serveritliveson:portnumber/nameofthedatabasetoconnectto
app.config['SQLALCHEMY_DATABASE_URI']= uristring
# this setting allows for learning about ORM and how flask connects to database; 
# useful for debugging when database interactions are not as expected
# Will echo sql commands that are generated by sqlalchemy to the terminal
app.config['SQLALCHEMY_ECHO']=True

# calling sqlalchemy constructor with flask application as parameter
# will create database object that can be used within app to interface with DB via Python
db = SQLAlchemy(app)

# Create persistent class to represent app specific data to store in DB
# Class will represent tasks for our list

app.secret_key='salmonsalmonsalmon'

# specifies that class extends db.Model class; db is the object created from SQLAlchemy
# db object has a class inside of it called Model; 
# this will inherit basic functionality that allows "Task" objects to be translated to relation setting
class Task(db.Model):
    # data that is assc with id field of Task class will go into a DB column
    # within that constructor we define the field type and other info
    # column within table that represents Task -- datatype is integer, and primary key
    id=db.Column(db.Integer, primary_key=True)
    # column within table that represents Task -- datatype is string with max length 120 char
    name=db.Column(db.String(120))
    completed = db.Column(db.Boolean)

    # provide a contstructor for Task object -- take user specified and assign to column
    def __init__(self, name):
        self.name = name
        # Another option could be to set a default of false in the declaration
        self.completed = False

class User(db.Model):
    #primary key id
    id=db.Column(db.Integer, primary_key=True)
    email=db.Column(db.String(120), unique=True)
    password=db.Column(db.String(30))

    def __init__(self, email, password):
        self.email = email
        self.password= password

@app.before_request
def require_login():
    # list of routes that users don't need to be logged in to see
    allowed_routes =['login', 'register']
    # if the page that user is req not in allowed_routes list AND 
    # if there is no key called 'email' in the session object dictionary
    # request.endpoint is the representation of the incoming http request with endpoint designating the requested path
    if request.endpoint not in allowed_routes and 'email' not in session:
        # this forces the user to login
        return redirect('/login')


@app.route('/', methods=['POST', 'GET'])
def index():

    if request.method == 'POST':
        task_name = request.form['task']
        # Create Task object with constructor
        new_task = Task(task_name)
        # Add new task object to db session
        db.session.add(new_task)
        # Push db session tasks to database
        db.session.commit()

    # populate variable with database entries
    tasks = Task.query.filter_by(completed=False).all()
    completed_tasks = Task.query.filter_by(completed=True).all()
    return render_template('todos.html',title="Get It Done!", tasks=tasks, completed_tasks=completed_tasks)

@app.route('/delete-task', methods=['POST'])
def delete_task():
    # Remove indicated task id from database
    task_id = int(request.form['task-id'])
    # query.get method calls a specific db entry by query
    task = Task.query.get(task_id)
    # delete the object returned from db query --> used task.id to grab object
    task.completed=True 
    db.session.add(task)
    db.session.commit()

    return redirect('/')

@app.route('/login', methods=['GET','POST'])
def login():

    if request.method == 'POST':
        user_email=request.form['email']
        form_password=request.form['password']
       
        user = User.query.filter_by(email=user_email).first()
        
        if user and user.password == form_password:
            #session is an obj that you can use to store data, associated with specific user from one request to another; allows server to remember data associated with that user
            success="Successfully logged in"
            session['email']=user_email
            # flash function 
            flash("Logged in")
            print(session)
            return redirect('/')
        else:
            return render_template('login.html', email=user_email)

    return render_template('login.html')

@app.route('/register' , methods=['GET','POST'])
def register():

    if request.method == 'POST':
        user_email = request.form['email']
        user_pwd = request.form['password']
        user_vpwd = request.form['verify']
        
        check_existing = User.query.filter_by(email=user_email).first()
        
        if user_email == "" or user_pwd == "":
            incomplete_error = "All fields must be completed"
            return render_template("register.html", incomplete_error=incomplete_error,email=user_email)

        if check_existing == None: 
            if user_pwd == user_vpwd:
                new_user=User(user_email, user_pwd)
                db.session.add(new_user)
                db.session.commit()
                session['email']=user_email
                return redirect('/')
            else:
                pwd_error = "Passwords must match"
                return render_template('register.html', pwd_error=pwd_error, email=user_email)
        else:
            error = "A user with that email already exists" 
            return render_template('register.html', user_error=error,email=user_email)

    return render_template('register.html')

@app.route('/logout')
def logout():
    # removes email from session to signal logout
    del session['email']
    return redirect('/')

if __name__ == '__main__':
    app.run()
